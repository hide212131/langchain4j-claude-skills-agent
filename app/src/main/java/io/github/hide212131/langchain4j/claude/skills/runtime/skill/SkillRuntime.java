package io.github.hide212131.langchain4j.claude.skills.runtime.skill;

import io.github.hide212131.langchain4j.claude.skills.infra.logging.WorkflowLogger;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Minimal runtime responsible for executing skills discovered in {@link SkillIndex}.
 * <p>
 * The implementation is intentionally lightweight: it recognises document-oriented skills (pptx) and
 * produces placeholder artefacts so that the full Plan→Act→Reflect loop can be exercised during the
 * MVP milestone. For other skills it returns simple summaries derived from metadata.
 */
public final class SkillRuntime {

    private static final String DEFAULT_DECK_FILE = "deck.pptx";

    private final SkillIndex skillIndex;
    private final Path outputDirectory;
    private final WorkflowLogger logger;

    public SkillRuntime(SkillIndex skillIndex, Path outputDirectory, WorkflowLogger logger) {
        this.skillIndex = Objects.requireNonNull(skillIndex, "skillIndex");
        this.outputDirectory = Objects.requireNonNull(outputDirectory, "outputDirectory");
        this.logger = Objects.requireNonNull(logger, "logger");
    }

    public ExecutionResult execute(String skillId, Map<String, Object> inputs) {
        if (skillId == null || skillId.isBlank()) {
            throw new IllegalArgumentException("skillId must be provided");
        }
        SkillIndex.SkillMetadata metadata = skillIndex.find(skillId)
                .orElseThrow(() -> new IllegalArgumentException("Unknown skill: " + skillId));
        Map<String, Object> safeInputs = inputs == null ? Map.of() : Map.copyOf(inputs);
        if (isSlideGenerationSkill(metadata)) {
            Path deckPath = resolveDeckPath(safeInputs);
            writeDeckPlaceholder(deckPath, metadata, safeInputs);
            logger.info("Skill {} produced PPTX artefact at {}", skillId, deckPath);
            return new ExecutionResult(skillId, Map.of("artifactPath", deckPath.toString()), deckPath);
        }
        String summary = metadata.description().isBlank() ? metadata.name() : metadata.description();
        logger.info("Skill {} produced summary output", skillId);
        return new ExecutionResult(skillId, Map.of("summary", summary), null);
    }

    private boolean isSlideGenerationSkill(SkillIndex.SkillMetadata metadata) {
        List<String> keywords = metadata.keywords();
        if (keywords == null || keywords.isEmpty()) {
            return false;
        }
        return keywords.stream().anyMatch(keyword -> {
            String lower = keyword.toLowerCase();
            return lower.contains("pptx") || lower.contains("slide") || lower.contains("presentation");
        });
    }

    private Path resolveDeckPath(Map<String, Object> inputs) {
        Object requested = inputs.get("outputFile");
        String fileName = requested instanceof String str && !str.isBlank() ? str : DEFAULT_DECK_FILE;
        Path path = outputDirectory.resolve(fileName);
        try {
            Files.createDirectories(path.getParent());
        } catch (IOException e) {
            throw new IllegalStateException("Failed to prepare output directory: " + path.getParent(), e);
        }
        return path;
    }

    private void writeDeckPlaceholder(
            Path deckPath, SkillIndex.SkillMetadata metadata, Map<String, Object> inputs) {
        String goal = Objects.toString(inputs.getOrDefault("goal", metadata.name()), metadata.name());
        String content = """
                Slide 1: %s overview
                Slide 2: Key guidelines aligned to %s
                Slide 3: Next steps for %s
                Goal: %s
                Generated by langchain4j-claude-skills-agent MVP runtime.
                """.formatted(metadata.name(), metadata.name(), metadata.name(), goal);
        try {
            Files.writeString(deckPath, content, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new IllegalStateException("Failed to write placeholder deck: " + deckPath, e);
        }
    }

    public record ExecutionResult(String skillId, Map<String, Object> outputs, Path artifactPath) {
        public ExecutionResult {
            Objects.requireNonNull(skillId, "skillId");
            Objects.requireNonNull(outputs, "outputs");
        }

        public boolean hasArtifact() {
            return artifactPath != null;
        }
    }
}
