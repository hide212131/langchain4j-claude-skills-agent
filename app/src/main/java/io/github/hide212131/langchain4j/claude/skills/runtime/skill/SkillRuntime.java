package io.github.hide212131.langchain4j.claude.skills.runtime.skill;

import io.github.hide212131.langchain4j.claude.skills.infra.logging.WorkflowLogger;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Minimal runtime responsible for executing skills discovered in {@link SkillIndex}.
 * <p>
 * The implementation is intentionally lightweight: it recognises document-generation skills
 * (those under document-skills/) and produces placeholder artefacts so that the full
 * Plan→Act→Reflect loop can be exercised during the MVP milestone. For other skills it
 * returns simple summaries derived from metadata. This approach is skill-agnostic and does
 * not depend on specific keywords metadata which is not part of the Claude Skills specification.
 */
public final class SkillRuntime {

    private static final String DEFAULT_DECK_FILE = "deck.pptx";

    private final SkillIndex skillIndex;
    private final Path outputDirectory;
    private final WorkflowLogger logger;

    public SkillRuntime(SkillIndex skillIndex, Path outputDirectory, WorkflowLogger logger) {
        this.skillIndex = Objects.requireNonNull(skillIndex, "skillIndex");
        this.outputDirectory = Objects.requireNonNull(outputDirectory, "outputDirectory");
        this.logger = Objects.requireNonNull(logger, "logger");
    }

    public ExecutionResult execute(String skillId, Map<String, Object> inputs) {
        if (skillId == null || skillId.isBlank()) {
            throw new IllegalArgumentException("skillId must be provided");
        }
        SkillIndex.SkillMetadata metadata = skillIndex.find(skillId)
                .orElseThrow(() -> new IllegalArgumentException("Unknown skill: " + skillId));
        Map<String, Object> safeInputs = inputs == null ? Map.of() : Map.copyOf(inputs);
        if (isDocumentGenerationSkill(metadata)) {
            Path deckPath = resolveDeckPath(safeInputs);
            writeDeckPlaceholder(deckPath, metadata, safeInputs);
            logger.info("Skill {} produced document artefact at {}", skillId, deckPath);
            return new ExecutionResult(skillId, Map.of("artifactPath", deckPath.toString()), deckPath);
        }
        String summary = metadata.description().isBlank() ? metadata.name() : metadata.description();
        logger.info("Skill {} produced summary output", skillId);
        return new ExecutionResult(skillId, Map.of("summary", summary), null);
    }

    private boolean isDocumentGenerationSkill(SkillIndex.SkillMetadata metadata) {
        // Use skill ID structure to determine if this is a document-generation skill.
        // Skills under "document-skills/" are considered document generators.
        // This is more generic than checking for specific keywords and works even when
        // skills don't have keywords metadata (which is not part of the Claude Skills spec).
        String id = metadata.id();
        return id.startsWith("document-skills/");
    }

    private Path resolveDeckPath(Map<String, Object> inputs) {
        Object requested = inputs.get("outputFile");
        String fileName = requested instanceof String str && !str.isBlank() ? str : DEFAULT_DECK_FILE;
        Path path = outputDirectory.resolve(fileName);
        try {
            Files.createDirectories(path.getParent());
        } catch (IOException e) {
            throw new IllegalStateException("Failed to prepare output directory: " + path.getParent(), e);
        }
        return path;
    }

    private void writeDeckPlaceholder(
            Path deckPath, SkillIndex.SkillMetadata metadata, Map<String, Object> inputs) {
        String goal = Objects.toString(inputs.getOrDefault("goal", metadata.name()), metadata.name());
        String content = """
                Slide 1: %s overview
                Slide 2: Key guidelines aligned to %s
                Slide 3: Next steps for %s
                Goal: %s
                Generated by langchain4j-claude-skills-agent MVP runtime.
                """.formatted(metadata.name(), metadata.name(), metadata.name(), goal);
        try {
            Files.writeString(deckPath, content, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new IllegalStateException("Failed to write placeholder deck: " + deckPath, e);
        }
    }

    public record ExecutionResult(String skillId, Map<String, Object> outputs, Path artifactPath) {
        public ExecutionResult {
            Objects.requireNonNull(skillId, "skillId");
            Objects.requireNonNull(outputs, "outputs");
        }

        public boolean hasArtifact() {
            return artifactPath != null;
        }
    }
}
