package io.github.hide212131.langchain4j.claude.skills.runtime.skill;

import io.github.hide212131.langchain4j.claude.skills.infra.logging.WorkflowLogger;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Minimal runtime responsible for executing skills discovered in {@link SkillIndex}.
 * <p>
 * The implementation is intentionally lightweight and completely generic: it produces placeholder
 * output for any skill to enable the full Plan→Act→Reflect loop to be exercised during the MVP
 * milestone. The actual skill selection is performed by the LLM based on skill name and description
 * metadata. This runtime makes no assumptions about skill types, folder structure, or specific
 * skill implementations.
 */
public final class SkillRuntime {

    private static final String DEFAULT_OUTPUT_FILE = "deck.pptx";  // MVP default, actual filename should come from inputs

    private final SkillIndex skillIndex;
    private final Path outputDirectory;
    private final WorkflowLogger logger;

    public SkillRuntime(SkillIndex skillIndex, Path outputDirectory, WorkflowLogger logger) {
        this.skillIndex = Objects.requireNonNull(skillIndex, "skillIndex");
        this.outputDirectory = Objects.requireNonNull(outputDirectory, "outputDirectory");
        this.logger = Objects.requireNonNull(logger, "logger");
    }

    public ExecutionResult execute(String skillId, Map<String, Object> inputs) {
        if (skillId == null || skillId.isBlank()) {
            throw new IllegalArgumentException("skillId must be provided");
        }
        SkillIndex.SkillMetadata metadata = skillIndex.find(skillId)
                .orElseThrow(() -> new IllegalArgumentException("Unknown skill: " + skillId));
        Map<String, Object> safeInputs = inputs == null ? Map.of() : Map.copyOf(inputs);
        
        // Generic MVP implementation: produce placeholder output for all skills
        Path outputPath = resolveOutputPath(safeInputs, metadata);
        writePlaceholderOutput(outputPath, metadata, safeInputs);
        logger.info("Skill {} produced output at {}", skillId, outputPath);
        
        String summary = metadata.description().isBlank() ? metadata.name() : metadata.description();
        return new ExecutionResult(
                skillId, 
                Map.of("artifactPath", outputPath.toString(), "summary", summary), 
                outputPath);
    }

    private Path resolveOutputPath(Map<String, Object> inputs, SkillIndex.SkillMetadata metadata) {
        Object requested = inputs.get("outputFile");
        String fileName;
        if (requested instanceof String str && !str.isBlank()) {
            fileName = str;
        } else {
            // Generate a default filename based on skill name
            fileName = DEFAULT_OUTPUT_FILE;
        }
        Path path = outputDirectory.resolve(fileName);
        try {
            Files.createDirectories(path.getParent());
        } catch (IOException e) {
            throw new IllegalStateException("Failed to prepare output directory: " + path.getParent(), e);
        }
        return path;
    }

    private void writePlaceholderOutput(
            Path outputPath, SkillIndex.SkillMetadata metadata, Map<String, Object> inputs) {
        String goal = Objects.toString(inputs.getOrDefault("goal", ""), "");
        String content = String.format(
                """
                Skill: %s
                Description: %s
                Goal: %s
                
                This is a placeholder output generated by the langchain4j-claude-skills-agent MVP runtime.
                In a full implementation, this would contain the actual skill execution result.
                """,
                metadata.name(),
                metadata.description(),
                goal);
        try {
            Files.writeString(outputPath, content, StandardCharsets.UTF_8);
        } catch (IOException e) {
            throw new IllegalStateException("Failed to write placeholder output: " + outputPath, e);
        }
    }

    public record ExecutionResult(String skillId, Map<String, Object> outputs, Path artifactPath) {
        public ExecutionResult {
            Objects.requireNonNull(skillId, "skillId");
            Objects.requireNonNull(outputs, "outputs");
        }

        public boolean hasArtifact() {
            return artifactPath != null;
        }
    }
}
